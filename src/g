BC.c:			BC->coeffNeu[I]         = -Physics->etaShear[C2]/dx/dx;
BC.c:			BC->coeffNeuNeigh[I]   =   Physics->etaShear[C2]/dx/dx;
BC.c:			BC->coeffNeu[I]         = -Physics->etaShear[C2]/dx/dx;
BC.c:			BC->coeffNeuNeigh[I]   =   Physics->etaShear[C2]/dx/dx;
BC.c:			BC->coeffNeu[I]         = -Physics->eta[C2]/dy/dy;
BC.c:			BC->coeffNeuNeigh[I]   =  Physics->eta[C2]/dy/dy;
BC.c:			BC->coeffNeu[I]         = -Physics->eta[C2]/dy/dy;
BC.c:			BC->coeffNeuNeigh[I]   =   Physics->eta[C2]/dy/dy;
char.c:	Physics->dt		/= Char->time;
char.c:	Physics->g[0] 	/= Char->acceleration;
char.c:	Physics->g[1] 	/= Char->acceleration;
char.c:	Physics->epsRef /= Char->strainrate;
eqSystem.c:		EtaN    = Physics->etaShear[ShearN];
eqSystem.c:		EtaS    = Physics->etaShear[ShearS];
eqSystem.c:		EtaE    = Physics->eta[NormalE];
eqSystem.c:		EtaW    = Physics->eta[NormalW];
eqSystem.c:		bloc = - Physics->g[1] * 0.5 * ( Physics->rho[NormalE] + Physics->rho[NormalW] );
eqSystem.c:				EtaW    = Physics->eta[NormalW];
eqSystem.c:				bloc = - Physics->g[1]  * 0.5 * ( Physics->rho[NormalE] + Physics->rho[NormalW] );
eqSystem.c:		EtaN    = Physics->eta[NormalN];
eqSystem.c:		EtaS    = Physics->eta[NormalS];
eqSystem.c:		EtaE    = Physics->etaShear[ShearE];
eqSystem.c:		EtaW    = Physics->etaShear[ShearW];
eqSystem.c:		bloc = - Physics->g[1] * 0.5 * ( Physics->rho[NormalN] + Physics->rho[NormalS] );
eqSystem.c:				EtaN    = Physics->eta[NormalN];
eqSystem.c:				EtaS    = Physics->eta[NormalS];
eqSystem.c:				EtaW    = Physics->etaShear[ShearW];
eqSystem.c:				bloc 	= - Physics->g[1] * 0.5 * ( Physics->rho[NormalN] + Physics->rho[NormalS] );
eqSystem.c:			Physics->P[iCell] = 0;
eqSystem.c:			Physics->P[i] = 0;
eqSystem.c:			Physics->Vx[i] = 0;
eqSystem.c:			Physics->Vy[i] = 0;
eqSystem.c:			Physics->P[i] = 0;
eqSystem.c:					printf("%.3f  ",Physics->P[ix+iy*Grid->nxC]);
eqSystem.c:			divVel = (Physics->Vx[VxE]-Physics->Vx[VxW])/Grid->dx + (Physics->Vy[VyN]-Physics->Vy[VyS])/Grid->dy;
eqSystem.c:			dum1 = (Physics->Vx[VxE]-Physics->Vx[VxW])/Grid->dx ;
eqSystem.c:			dum2 = (Physics->Vy[VyN]-Physics->Vy[VyS])/Grid->dy;
eqSystem.c:			//Physics->P[ix+iy*Grid->nxC] += EqSystem->penaltyFac*divVel;
eqSystem.c:			Physics->P[ix+iy*Grid->nxC] += K*divVel;
eqSystem.c:			//printf("ix=%i, iy=%i,  , VyN=%i, VyS=%i, VxE=%i, VxW=%i, Physics->Vx[VxE]=%.2f, Physics->Vx[VxW]=%.2f, Physics->Vy[VyN]=%.2f, Physics->Vy[VyS] = %.2f, dum1 = %.2e, dum2 = %.2e, sum = %.2e, P=%.4e\n",ix, iy, VyN, VyS, VxE, VxW, Physics->Vx[VxE], Physics->Vx[VxW], Physics->Vy[VyN], Physics->Vy[VyS], dum1, dum2, dum1+dum2, Physics->P[ix+iy*Grid->nxC]);
eqSystem.c:		//Physics->P[Grid->nCTot-1] = 0; //Add a dirichlet condition
eqSystem.c:			divVelE = (Physics->Vx[VxE] - Physics->Vx[VxC])/Grid->dx + (Physics->Vy[VyNE] - Physics->Vy[VySE])/Grid->dy;
eqSystem.c:			divVelW = (Physics->Vx[VxC] - Physics->Vx[VxW])/Grid->dx + (Physics->Vy[VyNW] - Physics->Vy[VySW])/Grid->dy;
eqSystem.c:			//EqSystem->b[iEq-1] -= (Physics->P[PE] - Physics->P[PW])/Grid->dx; // /!\ the minus one is there to take care of the fortran indexing (used by Pardiso)
eqSystem.c:			EqSystem->b[iEq] = EqSystem->b0[iEq] + (Physics->P[PE] - Physics->P[PW])/Grid->dx; // /!\ the minus one is there to take care of the fortran indexing (used by Pardiso)
eqSystem.c:			//printf("iEq=%i, PE=%.2e, PW=%.2e", iEq, Physics->P[PE], Physics->P[PW]);
eqSystem.c:			//printf("iEq=%i, ix=%i, iy=%i, VxW=%i, b=%.4e, dum=%.4e, DivVelE*K=%.4e, DivVelW*K=%.4e, PE=%.4e, PW=%.4e\n",iEq, ix, iy, VxW, EqSystem->b[iEq], dum, divVelE*K, divVelW*K, Physics->P[PE], Physics->P[PW]);
eqSystem.c:			divVelN = (Physics->Vy[VyN] - Physics->Vy[VyC])/Grid->dy    +    (Physics->Vx[VxNE] - Physics->Vx[VxNW])/Grid->dx;
eqSystem.c:			divVelS = (Physics->Vy[VyC] - Physics->Vy[VyS])/Grid->dy    +    (Physics->Vx[VxSE] - Physics->Vx[VxSW])/Grid->dx;
eqSystem.c:			//printf("ix = %i, iy = %i, divVelN = %.2e , divVelS = %.2e , VyC=%i, VyN=%i, VyS=%i, VxNE=%i, VxNW=%i, VxSE=%i, VxSW=%i, Physics->Vy[VyN]=%.2f , Physics->Vy[VyC]=%.2f, Physics->Vx[VxNE]=%.2f, Physics->Vx[VxNW]=%.2f   \n", ix, iy, divVelN, divVelS, VyC, VyN, VyS, VxNE, VxNW, VxSE, VxSW, Physics->Vy[VyN], Physics->Vy[VyC] , Physics->Vx[VxNE], Physics->Vx[VxNW]);
eqSystem.c:			//EqSystem->b[iEq-1] -= (Physics->P[PE] - Physics->P[PW])/Grid->dx; // /!\ the minus one is there to take care of the fortran indexing (used by Pardiso)
eqSystem.c:			EqSystem->b[iEq] = EqSystem->b0[iEq] + (Physics->P[PN] - Physics->P[PS])/Grid->dy; // /!\ the minus one is there to take care of the fortran indexing (used by Pardiso)
memory.c:	Physics->eta 			= (compute*) 	malloc( Grid->nxC*Grid->nyC * sizeof(compute) );
memory.c:	Physics->rho 			= (compute*) 	malloc( Grid->nxC*Grid->nyC * sizeof(compute) );
memory.c:	Physics->etaShear		= (compute*) 	malloc( Grid->nxS*Grid->nyS * sizeof(compute) );
memory.c:	Physics->Vx 			= (compute*) 	malloc( Grid->nVxTot 		* sizeof(compute) );
memory.c:	Physics->Vy 			= (compute*) 	malloc( Grid->nVyTot 		* sizeof(compute) );
memory.c:	Physics->P 				= (compute*) 	malloc( Grid->nCTot 		* sizeof(compute) );
memory.c:		Physics->Vx[i] = 0;
memory.c:		Physics->Vy[i] = 0;
memory.c:		Physics->P[i] = 0;
memory.c:	free( Physics->eta );
memory.c:	free( Physics->rho );
memory.c:	free( Physics->etaShear );
memory.c:	free(Physics->Vx);
memory.c:	free(Physics->Vy);
memory.c:	free(Physics->P);
particles.c:				Particles->xy[iP*2] += ( .25*(1.0-locX)*(1.0-locY)*Physics->Vx[Ix  +(Iy  )*Grid->nxVx]
particles.c:									   + .25*(1.0-locX)*(1.0+locY)*Physics->Vx[Ix  +(Iy+1)*Grid->nxVx]
particles.c:									   + .25*(1.0+locX)*(1.0+locY)*Physics->Vx[Ix+1+(Iy+1)*Grid->nxVx]
particles.c:									   + .25*(1.0+locX)*(1.0-locY)*Physics->Vx[Ix+1+(Iy  )*Grid->nxVx] ) * Physics->dt;;
particles.c:				Particles->xy[iP*2+1]  += (.25*(1.0-locX)*(1.0-locY)*Physics->Vy[Ix  +(Iy  )*Grid->nxVy]
particles.c:									     + .25*(1.0-locX)*(1.0+locY)*Physics->Vy[Ix  +(Iy+1)*Grid->nxVy]
particles.c:										 + .25*(1.0+locX)*(1.0+locY)*Physics->Vy[Ix+1+(Iy+1)*Grid->nxVy]
particles.c:										 + .25*(1.0+locX)*(1.0-locY)*Physics->Vy[Ix+1+(Iy  )*Grid->nxVy] ) * Physics->dt;
physics.c:		Physics->eta[iCell] = 0;
physics.c:		Physics->rho[iCell] = 0;
physics.c:						dVxdy += ( Physics->Vx[(IX  )+(IY+1)*Grid->nxVx]
physics.c:								 - Physics->Vx[(IX  )+(IY  )*Grid->nxVx] )/Grid->dy;
physics.c:						dVydx += ( Physics->Vy[(IX+1)+(IY  )*Grid->nxVy]
physics.c:								 - Physics->Vy[(IX  )+(IY  )*Grid->nxVy] )/Grid->dx;
physics.c:					dVxdx = (Physics->Vx[(ix+1) + (iy+1)*Grid->nxVx]
physics.c:						   - Physics->Vx[(ix  ) + (iy+1)*Grid->nxVx])/Grid->dx;
physics.c:					dVydy = (Physics->Vy[(ix+1) + (iy+1)*Grid->nxVy]
physics.c:						   - Physics->Vy[(ix+1) + (iy  )*Grid->nxVy])/Grid->dy;
physics.c:					//printf("ix=%i, iy=%i, locEps_II = %.3e, EpsRef = %.3e, dVxdx2=%.4e, dVydy2=%.4e\n",ix, iy, locEps_II,Physics->epsRef, dVxdx*dVxdx, dVydy*dVydy );
physics.c:						locEps_II = Physics->epsRef;
physics.c:					locEta = MatProps->eta0[phase] * pow(  (locEps_II/Physics->epsRef)    ,   1.0/MatProps->n[phase]-1.0 );
physics.c:							Physics->eta[I] += locEta * weight;
physics.c:							Physics->rho[I] += MatProps->rho0[phase] * weight;
physics.c:		Physics->eta[iCell] /= sumOfWeights[iCell];
physics.c:		Physics->rho[iCell] /= sumOfWeights[iCell];
physics.c:		if (Physics->eta[iCell]<Physics->etaMin) {
physics.c:			Physics->eta[iCell] = Physics->etaMin;
physics.c:		else if (Physics->eta[iCell]>Physics->etaMax) {
physics.c:			Physics->eta[iCell] = Physics->etaMax;
physics.c:				printf("%.3f  ", Physics->eta[C]);
physics.c:		Physics->Vx[i] = -1;
physics.c:		Physics->Vy[i] = -1;
physics.c:			Physics->P[i] = -1;
physics.c:				Physics->Vx[C] = EqSystem->x[InoDir];
physics.c:				Physics->Vx[C] = BC->valueDir[ findi(BC->listDir,BC->nDir,I) ];
physics.c:			if (Physics->Vx[C]*Physics->Vx[C] > maxVx)
physics.c:				maxVx = Physics->Vx[C]*Physics->Vx[C];
physics.c:				Physics->Vy[C] = EqSystem->x[InoDir];
physics.c:				Physics->Vy[C] = BC->valueDir[ findi(BC->listDir,BC->nDir,I) ];
physics.c:			if (Physics->Vy[C]*Physics->Vy[C] > maxVy)
physics.c:				maxVy = Physics->Vy[C]*Physics->Vy[C];
physics.c:					Physics->P[C] = EqSystem->x[InoDir];
physics.c:					Physics->P[C] = BC->valueDir[ findi(BC->listDir,BC->nDir,I) ];
physics.c:	Physics->maxV = sqrt(maxVx+maxVy);
physics.c:				printf("%.2f  ", Physics->Vx[C]);
physics.c:				printf("%.2f  ", Physics->Vy[C]);
physics.c:				printf("%.2f  ", Physics->P[C]);
visualization.c:				dVxdy += ( Physics->Vx[(Ix  )+(Iy+1)*Grid->nxVx]
visualization.c:					     - Physics->Vx[(Ix  )+(Iy  )*Grid->nxVx] )/Grid->dy;
visualization.c:				dVydx += ( Physics->Vy[(Ix+1)+(Iy  )*Grid->nxVy]
visualization.c:					     - Physics->Vy[(Ix  )+(Iy  )*Grid->nxVy] )/Grid->dx;
visualization.c:			dVxdx = (Physics->Vx[(ix+1) + (iy+1)*Grid->nxVx]
visualization.c:				   - Physics->Vx[(ix  ) + (iy+1)*Grid->nxVx])/Grid->dx;
visualization.c:			printf("%.2f  ", Physics->Vx[C]);
visualization.c:        	//Visu->U[I]  = (Physics->Vx[ix  +(iy  )*Grid->nxVx] + Physics->Vx[ix  +(iy+1)*Grid->nxVx])/2;
visualization.c:        	Visu->U[I] = (Physics->Vy[ix  +(iy  )*Grid->nxVy] + Physics->Vy[ix+1+(iy  )*Grid->nxVy])/2;
visualization.c:		Visu_updateCenterValue(Visu, Grid, Physics->eta, BC->SetupType);
